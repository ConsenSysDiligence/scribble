/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity ^0.6.0;

import "./__scribble_ReentrancyUtils.sol";

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

    function totalSupply() external returns (uint);

    function balanceOf(address account) external returns (uint);

    function allowance(address owner, address spender) external returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
}

contract ERC20 is __scribble_ReentrancyUtils, IERC20 {
    using SafeMath for uint;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    event Transfer(address indexed from, address indexed to, uint tokens);

    struct vars4 {
        bool __scribble_check_invs_at_end;
    }

    struct vars5 {
        bool __scribble_check_invs_at_end;
    }

    struct vars6 {
        bool old_1;
        uint256 old_2;
        uint256 old_3;
        uint256 old_4;
        uint256 old_5;
        bool __scribble_check_invs_at_end;
    }

    struct vars7 {
        bool __scribble_check_invs_at_end;
    }

    struct vars8 {
        bool old_6;
        uint256 old_7;
        uint256 old_8;
        uint256 old_9;
        uint256 old_10;
        uint256 old_11;
        uint256 old_12;
        bool __scribble_check_invs_at_end;
    }

    string public constant name = "ERC20Example";
    string public constant symbol = "XMPL";
    uint8 public constant decimals = 18;
    address_to_uint256.S internal balances;
    mapping(address => mapping(address => uint)) internal allowances;
    uint internal _totalSupply;

    constructor(uint total) public {
        __scribble_out_of_contract = false;
        _totalSupply = total;
        address_to_uint256.set(balances, msg.sender, _totalSupply);
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function totalSupply() override public returns (uint RET_0) {
        vars4 memory _v;
        _v.__scribble_check_invs_at_end = __scribble_out_of_contract;
        __scribble_out_of_contract = false;
        RET_0 = _original_ERC20_totalSupply();
        if (!(RET_0 == balances.sum)) {
            emit AssertionFailed("3: Result is equal to sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __scribble_out_of_contract = _v.__scribble_check_invs_at_end;
    }

    function _original_ERC20_totalSupply() private view returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address account) override public returns (uint RET_0) {
        vars5 memory _v;
        _v.__scribble_check_invs_at_end = __scribble_out_of_contract;
        __scribble_out_of_contract = false;
        RET_0 = _original_ERC20_balanceOf(account);
        if (!(RET_0 == address_to_uint256.get(balances, account))) {
            emit AssertionFailed("4: Returns the balance of owner in the balances mapping");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __scribble_out_of_contract = _v.__scribble_check_invs_at_end;
    }

    function _original_ERC20_balanceOf(address account) private view returns (uint) {
        return address_to_uint256.get(balances, account);
    }

    function transfer(address receiver, uint amount) override public returns (bool RET_0) {
        vars6 memory _v;
        _v.__scribble_check_invs_at_end = __scribble_out_of_contract;
        __scribble_out_of_contract = false;
        _v.old_1 = address_to_uint256.get(balances, msg.sender) >= amount;
        _v.old_2 = address_to_uint256.get(balances, msg.sender);
        _v.old_3 = address_to_uint256.get(balances, receiver);
        _v.old_4 = address_to_uint256.get(balances, receiver);
        _v.old_5 = address_to_uint256.get(balances, msg.sender);
        RET_0 = _original_ERC20_transfer(receiver, amount);
        if (!(_v.old_1)) {
            emit AssertionFailed("6: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_2 - amount) == address_to_uint256.get(balances, msg.sender)))) {
            emit AssertionFailed("7: The sender has value less balance");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_3 + amount) == address_to_uint256.get(balances, receiver)))) {
            emit AssertionFailed("8: The receiver receives _value");
            assert(false);
        }
        if (!((_v.old_4 + _v.old_5) == (address_to_uint256.get(balances, receiver) + address_to_uint256.get(balances, msg.sender)))) {
            emit AssertionFailed("9: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __scribble_out_of_contract = _v.__scribble_check_invs_at_end;
    }

    function _original_ERC20_transfer(address receiver, uint amount) private returns (bool) {
        require(amount <= address_to_uint256.get(balances, msg.sender));
        address_to_uint256.set(balances, msg.sender, address_to_uint256.get(balances, msg.sender).sub(amount));
        address_to_uint256.set(balances, receiver, address_to_uint256.get(balances, receiver).add(amount));
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function approve(address delegate, uint amount) override public returns (bool RET_0) {
        vars7 memory _v;
        _v.__scribble_check_invs_at_end = __scribble_out_of_contract;
        __scribble_out_of_contract = false;
        RET_0 = _original_ERC20_approve(delegate, amount);
        if (!(allowances[msg.sender][delegate] == amount)) {
            emit AssertionFailed("10: spender will have an allowance of value for this sender's balance");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __scribble_out_of_contract = _v.__scribble_check_invs_at_end;
    }

    function _original_ERC20_approve(address delegate, uint amount) private returns (bool) {
        allowances[msg.sender][delegate] = amount;
        emit Approval(msg.sender, delegate, amount);
        return true;
    }

    function allowance(address owner, address delegate) virtual override public returns (uint) {
        return allowances[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint amount) override public returns (bool RET_0) {
        vars8 memory _v;
        _v.__scribble_check_invs_at_end = __scribble_out_of_contract;
        __scribble_out_of_contract = false;
        _v.old_6 = address_to_uint256.get(balances, owner) >= amount;
        _v.old_7 = address_to_uint256.get(balances, owner);
        _v.old_8 = allowances[owner][msg.sender];
        _v.old_9 = allowances[owner][msg.sender];
        _v.old_10 = address_to_uint256.get(balances, buyer);
        _v.old_11 = address_to_uint256.get(balances, buyer);
        _v.old_12 = address_to_uint256.get(balances, owner);
        RET_0 = _original_ERC20_transferFrom(owner, buyer, amount);
        if (!(_v.old_6)) {
            emit AssertionFailed("11: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_7 - amount) == address_to_uint256.get(balances, owner)))) {
            emit AssertionFailed("12: The sender has value less balance");
            assert(false);
        }
        if (!((_v.old_8 - amount) == allowances[owner][msg.sender])) {
            emit AssertionFailed("13: The actor has value less allowance");
            assert(false);
        }
        if (!(_v.old_9 >= amount)) {
            emit AssertionFailed("14: The actor has enough allowance");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_10 + amount) == address_to_uint256.get(balances, buyer)))) {
            emit AssertionFailed("15: The receiver receives value");
            assert(false);
        }
        if (!((_v.old_11 + _v.old_12) == (address_to_uint256.get(balances, buyer) + address_to_uint256.get(balances, owner)))) {
            emit AssertionFailed("16: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __scribble_out_of_contract = _v.__scribble_check_invs_at_end;
    }

    function _original_ERC20_transferFrom(address owner, address buyer, uint amount) private returns (bool) {
        require(amount <= address_to_uint256.get(balances, owner));
        require(amount <= allowances[owner][msg.sender]);
        address_to_uint256.set(balances, owner, address_to_uint256.get(balances, owner).sub(amount));
        allowances[owner][msg.sender] = allowances[owner][msg.sender].sub(amount);
        address_to_uint256.set(balances, buyer, address_to_uint256.get(balances, buyer).add(amount));
        emit Transfer(owner, buyer, amount);
        return true;
    }

    /// Check only the current contract's state invariants
    function __scribble_ERC20_check_state_invariants_internal() internal {}

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual internal {
        __scribble_ERC20_check_state_invariants_internal();
    }
}

library SafeMath {
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b <= a, "Underflow");
        return a - b;
    }

    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "Overflow");
        return c;
    }
}