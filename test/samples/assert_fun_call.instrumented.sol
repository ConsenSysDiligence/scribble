/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity 0.8.7;

contract AssertFunCall {
    struct vars0 {
        uint256 oldSum;
        uint256 a1;
        uint256 b1;
        bool let_0;
        bool let_1;
    }

    uint internal t;

    function foo(uint x, uint y) public view returns (uint, uint) {
        return (x + t, y + t);
    }

    function boo(uint a, uint b) public pure returns (uint) {
        return a + b;
    }

    function main(uint a, uint b, uint newT) public returns (uint) {
        vars0 memory _v;
        t = newT;
        unchecked {
            _v.oldSum = a + b;
            (_v.a1, _v.b1) = foo(a, b);
            _v.let_0 = (_v.oldSum + (2 * 1)) == (_v.a1 + _v.b1);
            _v.let_1 = _v.let_0;
            if (!(_v.let_1)) {
                emit __ScribbleUtilsLib__60.AssertionFailed("000868:0066:000 0: ");
                assert(false);
            }
        }
        boo(a, b);
    }
}

library __ScribbleUtilsLib__60 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}
