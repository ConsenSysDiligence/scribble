/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity 0.8.19;

contract Sample {
    struct Some {
        uint a;
    }

    uint[3] internal a;
    uint[] internal b;
    Some internal c;

    function foo(uint256 x, uint256 y, uint256 z) public returns (uint256 RET_0) {
        RET_0 = _original_Sample_foo(x, y, z);
        unchecked {
            if (!(__ScribbleUtilsLib__35.eq_encoded("a", "b"))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("000507:0066:000 0: ");
                assert(false);
            }
            if (!(__ScribbleUtilsLib__35.eq_encoded(hex"01", hex"02"))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("000710:0066:000 1: ");
                assert(false);
            }
            if (!(__ScribbleUtilsLib__35.eq_encoded(abi.encode(Some(1)), abi.encode(c)))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("000931:0066:000 2: ");
                assert(false);
            }
            if (!(__ScribbleUtilsLib__35.eq_encoded(abi.encode(a), abi.encode(b)))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("001146:0066:000 3: ");
                assert(false);
            }
            if (!(__ScribbleUtilsLib__35.eq_encoded(abi.encode(a), "1"))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("001351:0066:000 4: ");
                assert(false);
            }
            if (!(__ScribbleUtilsLib__35.eq_encoded(hex"010203", abi.encode(b)))) {
                emit __ScribbleUtilsLib__35.AssertionFailed("001564:0066:000 5: ");
                assert(false);
            }
        }
    }

    function _original_Sample_foo(uint256 x, uint256 y, uint256 z) private returns (uint256) {
        return (x + y) + z;
    }
}

library __ScribbleUtilsLib__35 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }

    function eq_encoded(bytes memory a, bytes memory b) internal pure returns (bool) {
        if (a.length != b.length) return false;
        for (uint256 i = 0; i < a.length; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}
